// Time Complexity : O(log(m*n))
// Space Complexity : O(1)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No


// Your code here along with comments explaining your approach in three sentences only
/*
 * Using the fact that the rows are already sorted, binary search can be applied. 
 * if the mid element is less than target, left half is searched and right is discared. 
 * Formulas for row and column are mid/n and mid%n;
 */
class BinarySearch_1 {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0; 
        int right = (m * n -1);
        while(left <= right){
            int mid = (left+right)/2;
            int row = mid/n; 
            int col = mid % n;
            if(matrix[row][col] == target)
            return true; 
            else if (matrix[row][col] < target)
            left = mid +1;
            else if(matrix[row][col] > target)
            right = mid-1;
        }
        return false;
    }
}